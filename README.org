#+title: NICEMACS

[[./resources/nicemacs-logo.png]]

* Spacemacs configuration

** Usage notes
   
To tangle the =nicemacs.el= file from the command line execute the following
command:

#+begin_src sh
emacs README.org --batch --eval="(org-babel-tangle)"
#+end_src

Then to include this in your spacemacs configutation add the following
expression to =dotspacemacs/user-config=:

#+begin_src emacs-lisp
(load "/home/aez/Documents/nicemacs/nicemacs.el")
#+end_src

To quickly jump to this very org-mode file it will be useful to have a shortcut

#+BEGIN_SRC emacs-lisp :tangle nicemacs.el
(defun visit-nicemacs ()
  (interactive)
  (find-file "~/Documents/nicemacs/README.org"))
(spacemacs/set-leader-keys "oon" 'visit-nicemacs)
#+END_SRC

*** Emacs-LISP REPL

From time to time it will be useful to have access to an emacs lisp REPL. To
start this repl run the =ielm= command.

*** Configuration layers

This configuration is used from within spacemacs, so it seems appropriate that I
should also document the configuration layers that I use.

#+begin_src emacs-lisp
'(
     epub
     auto-completion
     better-defaults
     bibtex
     csv
     emacs-lisp
     ess
     git
     (haskell :variables
              haskell-completion-backend 'company-ghci
              haskell-process-type 'stack-ghci
              hsakell-enable-hindent-style "fundamental")
     helm
     html
     (javascript :variables
                 javascript-import-tool 'import-js
                 javascript-backend 'tern
                 javascript-fmt-tool 'web-beautify)
     latex
     markdown
     nixos
     org
     python
     (shell :variables
            shell-default-shell 'eshell
            shell-default-position "right"
            shell-default-height 40)
     speed-reading
     (spell-checking :variables
                     spell-checking-enable-by-default nil
                     enable-flyspell-auto-completion t)
     syntax-checking
     web-beautify
     yaml
     version-control
     )
#+end_src

** Stuff

To quickly toggle between the default spacemacs theme use =SPC t t=. Since this
is something that I want to do in a hurry if my retinas are burning this is a
useful shortcut.

#+begin_src emacs-lisp :tangle nicemacs.el
(spacemacs/set-leader-keys "tt" 'spacemacs/cycle-spacemacs-theme)
#+end_src

The spacemacs documentation recommends that you store all of your shortcuts with
a prefix of "o" for owner.

#+begin_src emacs-lisp :tangle nicemacs.el
(spacemacs/declare-prefix "o" "own-menu")
#+end_src

** Completion

The following potentially reduce the latency in input which can be increased by
unnecessary calls to a completion backend.

#+begin_src emacs-lisp :tangle nicemacs.el
(setq company-idle-delay 0.5)
(setq company-minimum-prefix-length 3)
#+end_src

** Haskell 

#+begin_src emacs-lisp :tangle nicemacs.el
(spacemacs/declare-prefix "oh" "haskell-menu")
(spacemacs/set-leader-keys "ohr" 'haskell-process-restart)
(defun haskell-insert-language-pragma ()
  "Insert \"{-# LANGUAGE <point here!> #-}\""
  (interactive)
  (progn
    (insert "{-# LANGUAGE #-}")
    (evil-backward-char 3)))
(spacemacs/set-leader-keys "ohl" 'haskell-insert-language-pragma)

;; pretty printing the code with hindent (requires executable to be on path)
(spacemacs/set-leader-keys "ohhr" 'hindent-reformat-region)
(spacemacs/set-leader-keys "ohhb" 'hindent-reformat-buffer)

;; Send the current buffer to the REPL
(spacemacs/set-leader-keys "ohb" 'haskell-process-load-file)

;; Switch to the haskell REPL.
(spacemacs/set-leader-keys "ohg" 'haskell-interactive-switch)

;; Set the input method to TeX for using unicode. Use C-\ to unset this.
(spacemacs/set-leader-keys "ohu" 'set-input-method)

;; Go to the next error found by flycheck
(spacemacs/set-leader-keys "ohe" 'flycheck-next-error)
#+end_src

** Latex and Bibtex

#+begin_src emacs-lisp :tangle nicemacs.el
(spacemacs/declare-prefix "ol" "latex")
(spacemacs/declare-prefix "ob" "bibtex-menu")
#+end_src

There are a couple of files that I want to have easy access to for reference and
to make minor edits. Having a function to access such a file easily is useful
for this.

#+begin_src emacs-lisp :tangle nicemacs.el
(defun visit-bib-and-tex-file (path-template)
  (interactive)
  (progn
    (find-file path-template)
    (goto-char 1)
    (recenter-top-bottom)))
#+end_src

This is a /latex/ file for my /reviews/ so the binding is =olr=.
 
#+begin_src emacs-lisp :tangle nicemacs.el
(defun review-tex-file ()
  "Open my review.tex file"
  (interactive)
  (visit-bib-and-tex-file "~/Documents/bibliography/review/review.tex"))

(spacemacs/set-leader-keys "olr" 'review-tex-file)
#+end_src

This is a /latex/ file for my reading /list/ so the binding is =oll=.

#+begin_src emacs-lisp :tangle nicemacs.el
(defun reading-list-tex-file ()
  "Open my review.tex file"
  (interactive)
  (visit-bib-and-tex-file "~/Documents/bibliography/review/reading-list.tex"))

(spacemacs/set-leader-keys "oll" 'reading-list-tex-file)
#+end_src

This is a /bibtex/ file for my /references/ so the binding is =obr=.

#+begin_src emacs-lisp :tangle nicemacs.el
(defun references-bib-file ()
  "Opens my bibtex references."
  (interactive)
  (visit-bib-and-tex-file "~/Documents/bibliography/references.bib"))

(spacemacs/set-leader-keys "obr" 'references-bib-file)
#+end_src

#+begin_src emacs-lisp :tangle nicemacs.el
(defun last-bib ()
  "Opens the most recent bibtex file in the Downloads directory
in a new buffer."
  (interactive)
  (let* ((bib-files (directory-files-and-attributes "~/Downloads" t ".*bib" "ctime"))
         (path-and-time (lambda (x) (list (first x) (eighth x))))
         (time-order (lambda (a b) (time-less-p (second b) (second a))))
         (most-recent (lambda (files) (car (car (sort (mapcar path-and-time files) time-order))))))
   (find-file (funcall most-recent bib-files))))
#+end_src

Bibtex requires that capital letters in the title be surrounded by braces to
ensure that they are capitalised correctly. The following function is a way to
quickly add these braces to long titles. Just hightlight the relevant text and
run the function.

#+begin_src emacs-lisp :tangle nicemacs.el
(defun bibtex-braces ()
  "Wrap upper case letters with brackets for bibtex titles."
  (interactive)
  (evil-ex "'<,'>s/\\([A-Z]+\\)/\\{\\1\\}/g"))
#+end_src

Some places seem reluctant to provide a bibtex file for a citation, but they all
seem to have RIS files available for download. There are tools to convert
between them. The following function makes it easier to use these tools by
finding the most recent RIS file in your downloads and running the convertion on
that to generate a file =new.bib= which may require a bit of manual tweaking but
is close to correct.

#+begin_src emacs-lisp :tangle nicemacs.el
  (defun bibtex-ris2bib ()
    "Convert the most recent RIS file in my downloads to a BIB
  file. TODO Make this less ugly please!"
    (interactive "*")
    (let ((ris-filepath (nth 1 (car (sort (mapcar (lambda (fp) (list (time-convert (file-attribute-modification-time (file-attributes fp)) 'integer) fp)) (directory-files "~/Downloads" 1 ".*ris")) (lambda (x y) (> (car x) (car y))))))))
      (shell-command (format "ris2xml %s | xml2bib > /home/aez/Downloads/new.bib" ris-filepath))))
#+end_src

Now we need some sensible key-bindings for this functionality. The following aim
to follow the naming used for the functionality because this is easier to
remember. *Owner* *Bibtex* *X* where

- *B* for /braces/ around upper case characters,
- *C* for /convert/ between RIS and bibtex,
- *F* for /format/ the current buffer,
- *L* for /last/ bibtex file in =Downloads= and
  
#+begin_src emacs-lisp :tangle nicemacs.el
(spacemacs/set-leader-keys "obl" 'last-bib)
(spacemacs/set-leader-keys "obf" 'bibtex-reformat)
(spacemacs/set-leader-keys "obb" 'bibtex-braces)
(spacemacs/set-leader-keys "obc" 'bibtex-ris2bib)
#+end_src

I often want to be able to open my reading notes quickly so it would be useful
to have a function to do that. This will be bound to =olp= because it is opening
/the/ PDF.

#+begin_src emacs-lisp :tangle nicemacs.el
(defun nicemacs-open-review-pdf ()
  "Open PDF of reading notes in evince."
  (interactive)
  (let ((pdf-viewer "evince")
        (review-path "/home/aez/Documents/bibliography/review/review.pdf"))
    (shell-command (concat pdf-viewer " " review-path " &"))))

(spacemacs/set-leader-keys "olp" 'nicemacs-open-review-pdf)
#+end_src

** Org-mode

Bindings for org-mode functionality start with =o o= for "owner org".

#+begin_src emacs-lisp :tangle nicemacs.el
(spacemacs/declare-prefix "oo" "orgo-menu")
#+end_src

*** Nicemacs journal

I want a directory just for my journal which potentially will vary between
machines so a variable to describe where they live is useful. To make it clear
that these are my variables and functions I will try to maintain =nicemacs-=
prefixes. We will also define some decent settings here.

#+begin_src emacs-lisp :tangle nicemacs.el
(defvar nicemacs-journal-directory "" "The directory for nicemacs journal files.")
(setq nicemacs-journal-directory "~/Documents/journal")

(setq org-agenda-start-day "-5d")
(setq org-agenda-span 30)
(setq org-agenda-start-on-weekday nil)
#+end_src

I need a way to talk about what the particular journal file is on any given
date. Updating the file about monthly seems sensible, so the filenames can
follow the pattern =journal-YYYY-MM=. *NOTE* that this function will set the
agenda file to the correct value whenever it is called and that the
=org-agenda-files= variable needs to be bound to a /list/ or files rather than
the name of a single file, otherwise it will interpret that single file as a
list of files to use.

#+begin_src emacs-lisp :tangle nicemacs.el
(defun nicemacs-journal-filepath ()
  "The filepath of the current journal file."
  (interactive)
  (let* ((filepath-template (concat nicemacs-journal-directory "/journal-%s.org"))
        (time-string (format-time-string "%Y-%m"))
        (agenda-file (format filepath-template time-string)))
    (setq org-agenda-files (list agenda-file))
    agenda-file))
#+end_src

I want functions to quickly visit our current journal file and to visit the
current agenda because this is something I do several times a day.

#+begin_src emacs-lisp :tangle nicemacs.el
(defun nicemacs-visit-journal ()
  "Opens the current journal file."
  (interactive)
  (let ((agenda-file (nicemacs-journal-filepath)))
    (find-file agenda-file)
    (goto-char 1)
    (recenter-top-bottom)))

(defun nicemacs-visit-agenda ()
  "Opens the agenda after checking it has been set correctly."
  (interactive)
  (let ((agenda-file (nicemacs-journal-filepath)))
    (org-agenda-list)))
#+end_src

To make it easy to access these we will bind them to come convenient keys.

#+begin_src emacs-lisp :tangle nicemacs.el
(spacemacs/set-leader-keys "ooj" 'nicemacs-visit-journal)
(spacemacs/set-leader-keys "ooa" 'nicemacs-visit-agenda)
(spacemacs/set-leader-keys "oos" 'org-schedule)
#+end_src

*** Website

Set up for publishing my website, note that this will write the output directly
to the github repository for the site.

#+begin_src emacs-lisp :tangle nicemacs.el
(require 'ox-publish)

(setq org-publish-project-alist
      '(
        ("org-notes"
         :base-directory "~/public-site/org/"
         :base-extension "org"
         :publishing-directory "~/aezarebski.github.io/"
         :recursive t
         :publishing-function org-html-publish-to-html
         :headline-levels 4
         :auto-preamble t
         )
        ("org-static"
         :base-directory "~/public-site/org/"
         :base-extension "css\\|js\\|png\\|jpg\\|gif\\|pdf\\|mp3\\|ogg\\|swf\\|txt\\|cur\\|svg\\|csv\\|json"
         :publishing-directory "~/aezarebski.github.io/"
         :recursive t
         :publishing-function org-publish-attachment
         )

        ("org" :components ("org-notes" "org-static"))
        ))
#+end_src

The following function simplifies the process of compiling the site and
commiting it to github so it goes live.

#+begin_src emacs-lisp :tangle nicemacs.el
(defun publish-my-site ()
  "Publish site and open version control for the published site."
  (interactive)
  (org-publish "org")
  (magit-status "~/aezarebski.github.io"))

(spacemacs/set-leader-keys "oop" 'publish-my-site)
#+end_src

The following function is useful for going to the root of my notes site which is
a sensible starting point for looking up material without the browser.

#+begin_src emacs-lisp :tangle nicemacs.el
(defun visit-my-site-index ()
  (interactive)
  (find-file "~/public-site/org/index.org"))
(spacemacs/set-leader-keys "oov" 'visit-my-site-index)
#+end_src

I used to have some commands for inserting tables and source code blocks into
org-mode files, but this functionality (and more) is all provided by
=yasnippet=. Just run =SPC i s= and it will start a search for the relevant
snippet: "source" and "table" are in there for example.

As of org-mode version about 9.3 the default behaviour appears to be that new
lines will be indented to the level of the current header. I would prefer that
new lines of text start at the start of the line. This can be achieved by
setting =org-adapt-indentation= to =nil=.

#+BEGIN_SRC emacs-lisp :tangle nicemacs.el
(setq org-adapt-indentation nil) 
#+END_SRC

*** Miscellaneous

#+begin_src emacs-lisp :tangle nicemacs.el
;; Tangle the current org file
(spacemacs/set-leader-keys "oot" 'org-babel-tangle)
;; open the export menu
(spacemacs/set-leader-keys "ooe" 'org-export-dispatch)

;; Make sure org files open with lines truncated
(add-hook 'org-mode-hook 'spacemacs/toggle-truncate-lines-on)
#+end_src

Orgmode can display images inline, however it is useful to be able to toggle
this feature occassionally, particularly if there are large images which take up
too much space. There is a function =org-toggle-inline-images= which does this.

#+begin_src emacs-lisp :tangle nicemacs.el
(spacemacs/set-leader-keys "ooi" 'org-toggle-inline-images)
#+end_src

The =org-latex-preview= function will show a preview of the latex fragment under
the mark. Running the command a second time will revert to the plain text.

#+begin_src emacs-lisp :tangle nicemacs.el
(spacemacs/set-leader-keys "ool" 'org-latex-preview)
#+end_src

You can try it in the following expressions \(\alpha\)

\[
\frac{a}{b}
\]

** Shells

To make =eshell= the default shell in spacemacs add the following to the
=dotspacemacs-configuration-layers=. The position and width might need a bit of
tweaking to get something you like, but it is pretty easy to adjust the window
set up anyway.

#+BEGIN_SRC emacs-lisp
    (shell :variables
           shell-default-shell 'eshell
           shell-default-position "right"
           shell-default-width 80)
#+END_SRC

It is useful to have a prefix for all the shell related commands

#+begin_src emacs-lisp :tangle nicemacs.el
(spacemacs/declare-prefix "os" "sheila-menu")
#+end_src

The following is for searching the shell history, but I rarely use it.

#+begin_src emacs-lisp :tangle nicemacs.el
(spacemacs/set-leader-keys "osh" 'helm-eshell-history)
#+end_src

Sometimes it is useful to just be able to open a regular bash shell. The
following binding helps with this.

#+begin_src emacs-lisp :tangle nicemacs.el
(spacemacs/set-leader-keys "osb" 'shell)
#+end_src

It is useful to be able to look at what aliases are currently defined for
eshell. The following function visits this file.

#+BEGIN_SRC emacs-lisp :tangle nicemacs.el
(defun eshell-aliases ()
  "Visit the file containing the eshell aliases."
  (interactive)
  (find-file-other-window eshell-aliases-file))
#+END_SRC

On =2021-01-11= the aliases I have are shown below. The =cdX= ones are for quick
navigation inspired by vim navigation.

#+begin_src 
alias cdkkk cd ../../..
alias cdkk cd ../..
alias cdk cd ..
alias ff find-file $1
#+end_src

Because no one has time for typing capital letters we will set the completion
variable in the shell to ignore case during tab completion.

#+BEGIN_SRC emacs-lisp :tangle nicemacs.el
(setq eshell-cmpl-ignore-case t)
#+END_SRC

The value of =exec-path= is the list of locations that emacs will look for
executables on. The =executable-find= function plays the role of =which= for
emacs. We need to add =~/.local/bin= so that it knows where to find haskell
executables and the =.nvm= path is so that it knows where to find javascript
programs that have been installed from npm.

#+BEGIN_SRC emacs-lisp :tangle nicemacs.el
(setq exec-path (append exec-path '("/home/aez/.local/bin")))
(setq exec-path (append exec-path '("/home/aez/.nvm/versions/node/v14.6.0/bin")))
#+END_SRC

** Emacs Speaks Statistics

#+begin_src emacs-lisp :tangle nicemacs.el
(setq spacemacs/ess-config
      '(progn
         ;; Follow Hadley Wickham's R style guide
         (setq ess-first-continued-statement-offset 2
               ess-continued-statement-offset 0
               ess-expression-offset 2
               ess-nuke-trailing-whitespace-p t
               ess-default-style 'DEFAULT)
         (when ess-disable-underscore-assign
           (setq ess-smart-S-assign-key nil))

         (define-key ess-doc-map "h" 'ess-display-help-on-object)
         (define-key ess-doc-map "p" 'ess-R-dv-pprint)
         (define-key ess-doc-map "t" 'ess-R-dv-ctable)
         (dolist (mode '(ess-r-mode ess-mode)))))

;; make documentation open in a useful mode in ess
(evil-set-initial-state 'ess-r-help-mode 'motion)
(spacemacs/declare-prefix "or" "r-menu")
(spacemacs/set-leader-keys "ors" 'run-ess-r)
(spacemacs/set-leader-keys "org" 'ess-switch-to-inferior-or-script-buffer)
(spacemacs/set-leader-keys "orr" 'ess-eval-region)
(spacemacs/set-leader-keys "orb" 'ess-eval-buffer)

;; Bindings for some devtools
(spacemacs/set-leader-keys "ordb" 'ess-r-devtools-build)
(spacemacs/set-leader-keys "ordi" 'ess-r-devtools-install-package)
(spacemacs/set-leader-keys "ordt" 'ess-r-devtools-test-package)
(spacemacs/set-leader-keys "ordl" 'ess-r-devtools-load-package)


;; Include a little function to run a particular file if it exists which can be
;; very useful for testing only specific parts of a package being developed
(defun ess-r-execute-sneaky ()
  "If a file .sneaky.R exists in the current directory then
source it into the R session."
  (interactive)
  (if (file-exists-p ".sneaky.R")
      (ess-r-package-eval-linewise
       "source(\".sneaky.R\")"
       "Running .sneaky.R")
    (message "Missing file .sneaky.R")))

(spacemacs/set-leader-keys "orx" 'ess-r-execute-sneaky)
#+end_src

The function =styler-reformat-buffer= will attempt to use the
=styler::style_file= function to format the R code in the current buffer and
then reload the buffer based on the changes to the file. If the styler package
is not installed then it fails but this gets reported in =*Messages*=. The use
of ="*"= in =interactive= ensures that you cannot accidentally run this function
on a read-only buffer.

#+begin_src emacs-lisp :tangle nicemacs.el
(defun styler-reformat-buffer ()
  "Run styler::style_file on the current buffer and then revert to load any changes."
  (interactive "*")
  (shell-command (concat "Rscript --slave --no-restore --quiet --no-init-file -e \"styler::style_file('" (buffer-file-name)  "')\""))
  (revert-buffer nil t)
)
(spacemacs/set-leader-keys "orf" 'styler-reformat-buffer)
#+end_src

*** TODO Fix the buffer display settings so that help covers the REPL

The following might be useful as a starting point for this

#+begin_src emacs-lisp
(info "(ess) Controlling buffer display")
#+end_src

*** Setting up =lintr= for static analysis

#+begin_src emacs-lisp :tangle nicemacs.el
  (setq ess-use-flymake nil)
  (use-package flycheck
    :ensure t
    :init
    (global-flycheck-mode t))
#+end_src

** Version control via magit

The following setting makes magit use the full frame when visiting the status.

#+begin_src emacs-lisp :tangle nicemacs.el
(setq magit-display-buffer-function #'magit-display-buffer-fullframe-status-v1)
#+end_src

There are a few projects where the same commit message use used often. It would
be nice to have a macro to fill this in each time for me. Since this is working
with commits I will use the prefix "c" followed by an indicator of the appropriate
commit message to use.

#+begin_src emacs-lisp :tangle nicemacs.el
(spacemacs/declare-prefix "oc" "commits-menu")
#+end_src

Apparently, this is [[https://xkcd.com/1205/][worth the time...]] After staging the
necessary files use =SPC o c j= for /journal/.

#+begin_src emacs-lisp :tangle nicemacs.el
(defun journal-commit-function ()
  "Create a commit and insert a string describing a generic
commit to my journal file. This should be fun from the magit
buffer"
  (interactive)
  (let* ((date-string (downcase (format-time-string "%A %l:%M %p")))
         (edit-string (format "-mupdate tasklist %s"  date-string)))
    (magit-commit-create `("--edit", edit-string))))

(spacemacs/set-leader-keys "ocj" 'journal-commit-function)
#+end_src

**** TODO This should really finish the commit and push it as well!

**** TODO There is a lot of duplicated code here! This should be refactored.

And when updating my /web/ page use =SPC o c w=.

#+begin_src emacs-lisp :tangle nicemacs.el
(defun website-commit-function ()
  (interactive)
  (let* ((date-string (downcase (format-time-string "%A %l:%M %p")))
         (edit-string (format "-mupdate website %s"  date-string)))
    (magit-commit-create `("--edit", edit-string))))

(spacemacs/set-leader-keys "ocw" 'website-commit-function)
#+end_src

And when we are updating the reading list it is always the same...

#+begin_src emacs-lisp :tangle nicemacs.el
(defun review-commit-function ()
  (interactive)
  (let* ((date-string (downcase (format-time-string "%A %l:%M %p")))
         (edit-string (format "-mupdate reading list %s"  date-string)))
    (magit-commit-create `("--edit", edit-string))))

(spacemacs/set-leader-keys "ocr" 'review-commit-function)
#+end_src

** File and buffer manipulation

#+begin_src emacs-lisp :tangle nicemacs.el
(defun kill-all-other-buffers ()
  "Kill all the buffers other than the current one."
  (interactive)
  (mapc 'kill-buffer (delq (current-buffer) (buffer-list))))

;; Define a short cut to close all windows except the current one without killing
;; their buffers.
(spacemacs/set-leader-keys "wD" 'spacemacs/window-manipulation-transient-state/delete-other-windows)

;; Define a short cut for C-g which is a little awkward.
(spacemacs/set-leader-keys "og" 'keyboard-quit)

;; Define a short cut for following files
(spacemacs/declare-prefix "of" "file-stuff")
(spacemacs/set-leader-keys "off" 'find-file-at-point)
(spacemacs/set-leader-keys "ofb" 'ibuffer)
(spacemacs/set-leader-keys "ofp" 'helm-projectile-find-file)
;; Open Ibuffer in the motion state rather than as the default emacs mode.
(evil-set-initial-state 'ibuffer-mode 'motion)
#+end_src

Sometimes it is useful to get the directory of the file shown in a buffer. This
is bound to =SPC o f d= for owner-files-directory.

#+begin_src emacs-lisp :tangle nicemacs.el
(defun message-working-directory ()
  "Print the directory of the current buffer."
  (interactive)
  (message default-directory))

(spacemacs/set-leader-keys "ofd" 'message-working-directory)
#+end_src

* Yasnippet snippets

Snippets usually live in =~/.emacs.d/private/snippets= in a directory which is
named after the major mode for them to be used in. You need to
=yas-recompile-all= and =yas-reload-all= for any changes to the snippets to take
effect.

*WARNING!* Tangling this file will write the snippets to your private snippet
directory which is convenient for me but may not be desirable for everyone. It
is set this way so that I don't have to remember to copy the tangled files over
all the time. To generate the directories that the snippets will be tangled to
you can run the following.

#+begin_src emacs-lisp
(make-directory "~/.emacs.d/private/snippets/ess-r-mode" t)
(make-directory "~/.emacs.d/private/snippets/json-mode" t)
(make-directory "~/.emacs.d/private/snippets/web-mode" t)
#+end_src

** Yasnippet configuration

I have started to get some weird warnings which [[https://github.com/syl20bnr/spacemacs/issues/12648][this issue]] suggests may be
something breaking in Emacs 27, but can be silenced with the following.

#+begin_src emacs-lisp :tangle nicemacs.el
(defvaralias
  'helm-c-yas-space-match-any-greedy
  'helm-yas-space-match-any-greedy
  "Temporary alias for Emacs27")
#+end_src

For some unknown reason, when I try to insert a snippet in the JSON mode I get
an error, "No JavaScript AST available". Things are working fine in other modes
so this might be something javascript specific, in which case, it is probably
easier just to call =yas-insert-snippet= directly when editing JSON.

** HTML and JS

#+BEGIN_SRC snippet :tangle ~/.emacs.d/private/snippets/web-mode/basic-template
# -*- mode: snippet -*-
# name: basic starter template
# key: basic-template
# --
<!DOCTYPE html>
<html>
    <head>

    </head>
    <body>

    </body>
</html>
#+end_src

** R 

A snippet to include the basic packages

#+BEGIN_SRC snippet :tangle ~/.emacs.d/private/snippets/ess-r-mode/rpacks
# -*- mode: snippet -*-
# name: Standard R packages
# key: rpacks
# --
library(dplyr)
library(purrr)
library(magrittr)
library(ggplot2)
library(stringr)
library(reshape2)
library(jsonlite)
#+END_SRC

A snippet to include packages that are useful when working with geographic data

#+BEGIN_SRC snippet :tangle ~/.emacs.d/private/snippets/ess-r-mode/rgeopacks
# -*- mode: snippet -*-
# name: R packages for computational geography
# key: rgeopacks
# --

library(sf)
library(countrycode)

$0
#+END_SRC

A snippet to include packages that are useful for doing MCMC

#+BEGIN_SRC snippet :tangle ~/.emacs.d/private/snippets/ess-r-mode/rmcmc
# -*- mode: snippet -*-
# name: R packages for MCMC
# key: rmcmc
# --

library(mcmc) # provides the \code{mcmc} class
library(coda) # provides the \code{metrop} function

$0
#+END_SRC

A snippet with sensible defaults for writing a data frame to CSV

#+BEGIN_SRC snippet :tangle ~/.emacs.d/private/snippets/ess-r-mode/rtable
# -*- mode: snippet -*-
# name: CSV output from R using write.table
# key: rtable
# --

write.table(x = $1,
            file = $2,
            sep = ",",
            row.names = FALSE)

$0
#+END_SRC

A snippet to provide a main function which only runs when the script is called
from the command line and passes any command line arguments through.

#+BEGIN_SRC snippet :tangle ~/.emacs.d/private/snippets/ess-r-mode/rmain
# -*- mode: snippet -*-
# name: Main function for an R script to be used at the command line
# key: rmain
# --

main <- function(args) {
  $0
}

if (!interactive()) {
  args <- commandArgs(trailingOnly = TRUE)
  main(args)
}
#+END_SRC

** Vega-Lite

The following files need to be moved into the correct snippet directory for your
configuration.

A snippet for a very simple scatter plot in vega-lite.

#+BEGIN_SRC snippet :tangle ~/.emacs.d/private/snippets/json-mode/vl-scatter-plot
# -*- mode: snippet -*-
# name: vega-lite scatter plot
# key: vl-scatter-plot
# --

{
    "$schema": "https://vega.github.io/schema/vega-lite/v4.json",
    "data": {
        "url": "$1"
    },
    "mark": "point",
    "encoding": {
        "x": {
            "field": "$2",
            "type": "quantitative"
        },
        "y": {
            "field": "$3",
            "type": "quantitative"
        }
    }
}
#+END_SRC

A snippet for a very simple histogram in vega-lite.

#+BEGIN_SRC snippet :tangle ~/.emacs.d/private/snippets/json-mode/vl-histogram
# -*- mode: snippet -*-
# name: vega-lite histogram
# key: vl-histogram
# --

{
    "$schema": "https://vega.github.io/schema/vega-lite/v4.json",
    "data": {
        "url": "$1"
    },
    "mark": "bar",
    "encoding": {
        "x": {
            "bin": true,
            "field": "$2"
        },
        "y": {
            "aggregate": "count"
        }
    }
}
#+END_SRC

** Writing

I use the following as a format for recording information about journals that
are relevant to my research.

#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# name: Description of an academic journal
# key: journal
# --
{
    "name": "$1",
    "publisher": "",
    "url": "",
    "ISO": "",
    "JCR": "",
    "metric": [
        {
            "year": ,
            "impactFactor":
        }
    ],
    "tenRelated": [
    ]
}
#+END_SRC

* Maxima

I have written a [[file:./maxima/README.org][Maxima layer]] for working with maxima in spacemacs. To make use
of it, copy the directory =maxima= into =~/.emacs.d/private/= and add =maxima=
to the layers list. Unfortunately it breaks most of the time so do not use it
yet.

** TODO Work out how to write a bloody layer for this!!!

I just can't get a proper maxima layer set up so here is the basic functionality
stored in the owner menu.

#+BEGIN_SRC emacs-lisp :tangle nicemacs.el
(load "/usr/share/emacs/site-lisp/maxima/maxima-font-lock.el")
(load "/usr/share/emacs/site-lisp/maxima/maxima.el")
(spacemacs/declare-prefix "om" "maxima-menu")
(spacemacs/set-leader-keys "omsb" 'maxima-send-buffer)
(spacemacs/set-leader-keys "omsr" 'maxima-send-region)
(spacemacs/set-leader-keys "omi" 'maxima-info)
#+END_SRC
