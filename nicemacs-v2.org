#+title: NICEMACS
#+Time-stamp: <Last modified: 2023-04-06 10:08:15>
#+startup: noinlineimages
#+startup: overview
#+OPTIONS: toc:nil
#+OPTIONS: num:nil
#+HTML_HEAD: <link id="stylesheet" rel="stylesheet" type="text/css" href="../../css/stylesheet.css" />

[[file:../../index.org][Home]]

#+attr_html: :width 300px
[[./resources/nicemacs-logo.png]]

#+TOC: headlines 2

* Nicemacs v2

** Ideas

*** Checking that a given set of directories and files exist

** STUFF 1

#+begin_src emacs-lisp :tangle nicemacs-v2.el :comments link
  ;;; Nicemacs.v2 -*- lexical-binding: t -*-
  ;;; ==================================================================
  ;;
  ;;   ███╗   ██╗██╗ ██████╗███████╗███╗   ███╗ █████╗  ██████╗███████╗
  ;;   ████╗  ██║██║██╔════╝██╔════╝████╗ ████║██╔══██╗██╔════╝██╔════╝
  ;;   ██╔██╗ ██║██║██║     █████╗  ██╔████╔██║███████║██║     ███████╗
  ;;   ██║╚██╗██║██║██║     ██╔══╝  ██║╚██╔╝██║██╔══██║██║     ╚════██║
  ;;   ██║ ╚████║██║╚██████╗███████╗██║ ╚═╝ ██║██║  ██║╚██████╗███████║
  ;;   ╚═╝  ╚═══╝╚═╝ ╚═════╝╚══════╝╚═╝     ╚═╝╚═╝  ╚═╝ ╚═════╝╚══════╝
  ;;
  ;; To update your packages carry out the following steps:
  ;;
  ;; 1. M-x list-packages
  ;; 2. Press `r' to refresh
  ;; 3. Press `U' to mark upgradable packages
  ;; 4. Press `x' to execute the upgrades
  ;;
  ;;
  ;;  Maybe just: don't neglect the Elisp manual.  I've read it _far_
  ;;  more than the regular Emacs manual, and it's surprisingly fun.
  ;;  Seeing Emacs as an interactive lisp machine to be programmed
  ;;  rather than an editor to be configured makes many things easier.
  ;;
  ;;  ~ Tim Vaughan (2023)
  ;;
  ;; Packages used
  ;; -------------
  ;;
  ;; - `cl-lib'
  ;; - `copilot'
  ;; - `dired'
  ;; - `ess' Emacs Speaks Statistics
  ;; - `ess-site'
  ;; - `evil' Extensible Vi layer for Emacs.
  ;; - `evil-collection' A set of keybindings for Evil mode
  ;; - `evil-leader' let there be <leader>
  ;; - `evil-mc'
  ;; - `evil-mc-extras' Extra functionality for evil-mc
  ;; - `evil-surround'
  ;; - `flyspell'
  ;; - `hl-todo' Highlight TODO and similar keywords
  ;; - `htmlize' Convert buffer text and decorations to HTML.
  ;; - `magit' A Git porcelain inside Emacs.
  ;; - `markdown-mode' Major mode for Markdown-formatted text
  ;; - `multiple-cursors' Multiple cursors for Emacs.
  ;; - `ligature' Ligature support for Emacs.
  ;; - `quarto-mode' A (poly)mode for https://quarto.org
  ;; - `rainbow-mode' Colorize color names in buffers
  ;; - `s' The long lost Emacs string manipulation library.
  ;; - `solarized-theme' The Solarized color theme
  ;; - `which-key' Display available keybindings in popup
  ;; - `winum' Navigate windows and frames using numbers.
  ;; - `writegood-mode' Polish up poor writing on the fly
  ;; - `yasnippet' Yet another snippet extension for Emacs
  ;; - `yasnippet-snippets' Collection of yasnippet snippets
  ;;
  ;; Changelog
  ;; ---------
  ;;
  ;; - 2023-06
  ;;   + Include the `cdf' function for easier eshell navigation.
  ;;   + Include keys for ESS devtools integration.
  ;;   + Include wrapper around `pp-emacs-lisp-code'.
  ;;   + Add some configuration for `nxml-mode'.
  ;;   + Start using `polymode' (and friends) so I can write R with from
  ;;     within `org-mode'.
  ;;   + Configure the `fill-column' to use a clearer face.
  ;;
  ;; - 2023-05
  ;;   + Use the `use-package' macro.
  ;;   + Use the `calfw' package for a calendar view of my agenda
  ;;   + Remove racket/scheme pacakge
  ;;   + Include option to accept AI suggestions line by line.
  ;;   + Include a linter function for R (using `formatR').
  ;;   + Use the `unfill' package for better paragraph un/filling.
  ;;   + Use the `lorem-ipsum' package for convenient dummy text.
  ;;   + Include python configuration.
  ;;
  ;; - 2023-04
  ;;   + Set up an org-mode file for documentation with tangling and
  ;;     detangling.
  ;;   + Use `S <x>` in visual mode to surround the region in <x>.
  ;;   + Use `SPC b s <x>` to open a scratch buffer in mode<x>
  ;;   + Edit `message-buffer-file-name' so it works in `dired'.
  ;;   + Extend `before-save-hook' to avoid accidental trailing
  ;;     whitespace.
  ;;   + Use JetBrains Mono as the font with ligatures.
  ;;
  ;;; ==================================================================



  (require 'package)
  (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)
  (add-to-list 'package-archives '("nongnu" . "https://elpa.nongnu.org/nongnu/") t)
  (add-to-list 'package-archives '("gnu" . "https://elpa.gnu.org/packages/") t)

  (package-initialize)
  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))

  (eval-when-compile
    (require 'use-package))
  (require 'bind-key)

  (setq user-full-name "Alexander E. Zarebski")

  (defvar nice-journal-directory "~/Documents/journal/"
    "The directory for nicemacs journal files.")
  (defvar nice-notes-directory "~/public-site/org/notes"
    "The directory for nicemacs notes files.")
  (defvar nice-resources-dir "~/Documents/nicemacs/resources"
    "The path to the nicemacs resources directory on this machine.")
  (defvar nice-nicemacs-directory "~/Documents/nicemacs"
    "The path to the nicemacs directory on this machine.")

  (use-package cl-lib
    :ensure t)

  ;; Be evil
  ;; -------
  ;;
  ;; Evil surroundings
  ;;
  ;; 1. Enter visual mode and select the text as the region.
  ;; 2. Press `S'.
  ;; 3. Type the symbol to surround it (note, if it is part of a opening
  ;;    and closing pair, the opening includes a space and the closing
  ;;    does not.)
  ;;

  (setq evil-want-keybinding nil)

  (use-package evil
    :ensure t
    :init
    (evil-mode 1))

  (use-package evil-leader
    :ensure t
    :config
    (evil-leader-mode 1)
    (global-evil-leader-mode 1)
    (evil-leader/set-key "t s" 'evil-surround-mode)
    (evil-leader/set-leader "<SPC>")
    (evil-leader/set-key "<SPC>" 'execute-extended-command))

  (use-package evil-collection
    :ensure t
    :config
    (evil-collection-init))

  (use-package evil-surround
    :ensure t
    :config
    (global-evil-surround-mode 1))

  ;; Look stunning
  ;; =============
  ;;
  ;; To install JetBrains Mono, or any other font, follow these steps:
  ;;
  ;; 1. Download and extract the font, you should have a "ttf" directory
  ;;    containing the font files.
  ;; 2. Create a font directory if you don't already have one
  ;;    $ mkdir -p ~/.local/share/fonts
  ;; 3. Copy the font files to the font directory:
  ;;    $ cp path/to/extracted/ttf/*.ttf ~/.local/share/fonts
  ;; 4. Update the font cache:
  ;;    $ fc-cache -f -v
  ;;

  (set-frame-font "JetBrains Mono" nil t)
  (ligature-set-ligatures 'prog-mode '("-|" "-~" "---" "-<<" "-<" "--" "->" "->>" "-->" "///" "/=" "/=="
				       "/>" "//" "/*" "*>" "***" "*/" "<-" "<<-" "<=>" "<=" "<|" "<||"
				       "<|||" "<|>" "<:" "<>" "<-<" "<<<" "<==" "<<=" "<=<" "<==>" "<-|"
				       "<<" "<~>" "<=|" "<~~" "<~" "<$>" "<$" "<+>" "<+" "</>" "</" "<*"
				       "<*>" "<->" "<!--" ":>" ":<" ":::" "::" ":?" ":?>" ":=" "::=" "=>>"
				       "==>" "=/=" "=!=" "=>" "===" "=:=" "==" "!==" "!!" "!=" ">]" ">:"
				       ">>-" ">>=" ">=>" ">>>" ">-" ">=" "&&&" "&&" "|||>" "||>" "|>" "|]"
				       "|}" "|=>" "|->" "|=" "||-" "|-" "||=" "||" ".." ".?" ".=" ".-" "..<"
				       "..." "+++" "+>" "++" "[||]" "[<" "[|" "{|" "??" "?." "?=" "?:" "##"
				       "###" "####" "#[" "#{" "#=" "#!" "#:" "#_(" "#_" "#?" "#(" ";;" "_|_"
				       "__" "~~" "~~>" "~>" "~-" "~@" "$>" "^=" "]#"))
  (global-ligature-mode t)

  (defun toggle-ligatures ()
    "Toggle ligatures on and off."
    (interactive)
    (if (bound-and-true-p global-ligature-mode)
	(global-ligature-mode -1)
      (global-ligature-mode 1)))
  (evil-leader/set-key "t l" 'toggle-ligatures)

  (setq-default scroll-bar-width 10)
  (setq-default left-fringe-width 10)
  (setq-default right-fringe-width 10)

  ;; I dislike trailing whitespace creeping into my files so the
  ;; following will make it visible and automatically remove it upon
  ;; saving. NOTE setting `show-trailing-whitespace' globally leads to
  ;; some things being highlighted in other buffers such as `calendar'
  ;; where they should not be hightlight. Doing it with
  ;; `nice-show-trailing-whitespace' ensures it is set locally as
  ;; appropriate.
  (defun nice-show-trailing-whitespace ()
    "Enable trailing whitespace highlighting only when editing a file."
    (setq show-trailing-whitespace (buffer-file-name)))
  (add-hook 'find-file-hook 'nice-show-trailing-whitespace)
  (add-hook 'before-save-hook 'delete-trailing-whitespace)

  (use-package hl-todo
    :ensure t
    :config (global-hl-todo-mode))

  (setq nice-colours-alist
	'((strong-warning . "red")
	  (weak-warning . "magenta")
	  (weak-note . "cyan")
	  (strong-note . "blue")
	  (light-theme-comment-background . "#e4ecda")
	  (light-theme-comment-foreground . "#207e7b")
	  (light-theme-shadow-background . "#eee8d5")
	  (light-theme-shadow-foreground . "#93a1a1")
	  (dark-theme-comment-background . "#207e7b")
	  (dark-theme-comment-foreground . "#e4ecda")
	  (dark-theme-shadow-background . "#202c2a")
	  (dark-theme-shadow-foreground . "#254d48")))

  (defun nice-colour (colour)
    "Return the colour associated with the symbol COLOUR."
    (cdr (assoc colour nice-colours-alist)))

  (setq hl-todo-keyword-faces
	`(("TODO"   . ,(nice-colour 'strong-warning))
	  ("FIXME"  . ,(nice-colour 'weak-warning))
	  ("NOTE"   . ,(nice-colour 'weak-note))
	  ("DONE"   . ,(nice-colour 'strong-note))))

  (setq fill-column 70)

  (defun nice-toggle-fill-column-indicator ()
    "Toggle display of the fill column indicator.

  When active, the indicator is set to a vertical line. It also
  turns on `display-fill-column-indicator-mode' if it's not already
  active, and turns it off if it is."
    (interactive)
    (display-fill-column-indicator-mode 'toggle)
    (when display-fill-column-indicator-mode
      (setq display-fill-column-indicator-character ?\u2502)
      (set-face-attribute 'fill-column-indicator nil
			  :foreground (nice-colour 'weak-warning)
			  :weight 'bold)))

  (evil-leader/set-key "t f" 'nice-toggle-fill-column-indicator)

  (add-to-list `custom-theme-load-path "~/.emacs.d/themes/")
  (load-theme 'solarized-light-high-contrast t)

  (defun nice-set-theme (theme comment-bg comment-fg shadow-bg shadow-fg)
    (load-theme theme t)
    (let ((comment-face `((t (:background ,comment-bg
					  :foreground ,comment-fg
					  :slant normal)))))
      (setq font-lock-comment-delimiter-face comment-face)
      (setq font-lock-comment-face comment-face))
    (set-face-background 'mode-line comment-bg)
    (set-face-foreground 'mode-line comment-fg)
    (set-face-background 'mode-line-inactive shadow-bg)
    (set-face-foreground 'mode-line-inactive shadow-fg))

  (defun nice-toggle-themes ()
    "Toggle between two themes: solarized-light-high-contrast and
  solarized-dark-high-contrast and adjust the comment face to one
  that is visible in both."
    (interactive)
    (if (eq (car custom-enabled-themes) 'solarized-light-high-contrast)
	(progn
	  (disable-theme 'solarized-light-high-contrast)
	  (nice-set-theme 'solarized-dark-high-contrast
			  (nice-colour 'dark-theme-comment-background)
			  (nice-colour 'dark-theme-comment-foreground)
			  (nice-colour 'dark-theme-shadow-background)
			  (nice-colour 'dark-theme-shadow-foreground)))
      (progn
	(disable-theme 'solarized-dark-high-contrast)
	(nice-set-theme 'solarized-light-high-contrast
			(nice-colour 'light-theme-comment-background)
			(nice-colour 'light-theme-comment-foreground)
			(nice-colour 'light-theme-shadow-background)
			(nice-colour 'light-theme-shadow-foreground)))))

  (evil-leader/set-key "t t" 'nice-toggle-themes)

  (tool-bar-mode -1)

  (global-hl-line-mode t)
  (set-face-attribute 'hl-line nil :background "#eee8d5")

  (defun next-window-and-pulse ()
    "Switch to another window and pulse the current window."
    (interactive)
    (other-window 1)
    (let ((orig-color (face-background 'mode-line)))
      (set-face-background 'mode-line "#dc322f")
      (sit-for 0.1)
      (set-face-background 'mode-line orig-color)))

  (defun previous-window-and-pulse ()
    "Switch to another window and pulse the current window."
    (interactive)
    (other-window -1)
    (let ((orig-color (face-background 'mode-line)))
      (set-face-background 'mode-line "#dc322f")
      (sit-for 0.1)
      (set-face-background 'mode-line orig-color)))

  ;; Rainbow-mode will highlight strings indicating colours,
  ;; e.g. hexcodes in their corresponding colour.
  (use-package rainbow-mode
    :ensure t
    :hook ((emacs-lisp-mode . rainbow-mode)
	   (ess-mode . rainbow-mode)))

  (setq inhibit-splash-screen t)

  (evil-leader/set-key
    "z j" 'text-scale-decrease
    "z k" 'text-scale-increase)

  ;; Be sensible
  ;; ===========

  (use-package unfill
    :ensure t
    :bind ("M-q" . unfill-toggle))

  (evil-leader/set-key
    "q r" 'restart-emacs
    "q q" 'save-buffers-kill-emacs)

  ;; Frame related commands will have keys starting with `F'.
  (evil-leader/set-key "F f" 'toggle-frame-fullscreen)

  (defun nice-pop-out-window ()
    "Pop the current window out into a new frame.

  If there is only a single window then do nothing because it is
  already in its own frame."
    (interactive)
    (unless (one-window-p)
      (let ((current-buffer (current-buffer)))
	(delete-window)
	(display-buffer-pop-up-frame current-buffer nil))))

  (evil-leader/set-key "F p" 'nice-pop-out-window)

  ;; The which-key package is a great way to be reminded of what keys
  ;; are available from the start of a key sequence.
  (require 'which-key)
  (which-key-mode)
  (setq which-key-idle-delay 0.3)
  (require 'which-key)
  (which-key-mode)

  (setq key-description-pairs
	'(("SPC a" . "Agenda (org-mode)")
	  ("SPC b" . "Buffers")
	  ("SPC c" . "Cursors")
	  ("SPC c" . "Delete")
	  ("SPC f" . "Files/Dired")
	  ("SPC F" . "Frame")
	  ("SPC g" . "Git (magit)")
	  ("SPC g c" . "Commits")
	  ("SPC h" . "HELP!!!")
	  ("SPC m" . "Major")
	  ("SPC m d" . "devtools (ESS)")
	  ("SPC m s" . "REPL (prog)/Sort (dired)")
	  ("SPC m c" . "Code lint/format")
	  ("SPC q" . "Quit/Exit")
	  ("SPC s" . "Shell/Search")
	  ("SPC S" . "Spelling")
	  ("SPC t" . "Toggles")
	  ("SPC v" . "Visitors")
	  ("SPC v b" . "Bibtex")
	  ("SPC v f" . "Files")
	  ("SPC v d" . "Directories")
	  ("SPC w" . "Windows")
	  ("SPC y" . "Yasnippet")
	  ("SPC z" . "Zoom (without a mouse)")))

  (dolist (pair key-description-pairs)
    (which-key-add-key-based-replacements (car pair) (cdr pair)))

  (defmacro nice-meld-files (name fa fb key)
    "Generate function named nice-meld-NAME which opens meld diff for
  files FA and FB using SPC f m KEY."
    `(progn
       (defun ,(intern (format "nice-meld-%s" name)) ()
	 (interactive)
	 (async-shell-command ,(format "meld %s %s &" fa fb)))
       (evil-leader/set-key ,(concat "f m " key) (intern ,(format "nice-meld-%s" name)))))

  (nice-meld-files "init" "~/.emacs.d/init.el"
		   "~/Documents/nicemacs/nicemacs-v2.el"
		   "i")
  (nice-meld-files "aspell" "~/.aspell.en.pws"
		   "~/Documents/nicemacs/resources/aspell.en.pws"
		   "a")

  (defun nice-meld ()
    "Prompt for two files and show the difference between them using
  `meld`."
    (interactive)
    (let ((file1 (read-file-name "First file: "))
	  (file2 (read-file-name "Second file: ")))
      (shell-command (format "meld %s %s &" file1 file2))))

  (evil-leader/set-key "f m m" 'nice-meld)

  ;; The `winum' package facilitates switching between windows using
  ;; numbers which appear in the bottom left hand of the window, at the
  ;; start of the mode-line.
  (require 'winum)
  (winum-mode)
  (setq winum-format " %s ")
  (custom-set-faces
   `(winum-face
     ((t
       (:foreground ,(nice-colour 'weak-warning)
	:weight bold
	:underline nil
	:height 1.1)))))
  (evil-leader/set-key
    "0" 'winum-select-window-0
    "1" 'winum-select-window-1
    "2" 'winum-select-window-2
    "3" 'winum-select-window-3
    "4" 'winum-select-window-4
    "5" 'winum-select-window-5
    "6" 'winum-select-window-6
    "7" 'winum-select-window-7
    "8" 'winum-select-window-8
    "9" 'winum-select-window-9)

  ;; Adjust the windows so that they are all the same size.
  (evil-leader/set-key "w b" 'balance-windows)

  (defun nice-balance-windows-alt ()
    "Balance windows such that the current window receives a certain
  amount of the of the frame's width and height."
    (interactive)
    (balance-windows)
    (let* ((proportion 0.7)
	   (frame-width (frame-width))
	   (frame-height (frame-height))
	   (desired-width (floor (* proportion frame-width)))
	   (desired-height (floor (* proportion frame-height))))
      (enlarge-window-horizontally (- desired-width (window-width)))
      (enlarge-window (- desired-height (window-height)))))
  (evil-leader/set-key "w a" 'nice-balance-windows-alt)
#+end_src

** Shells

#+begin_src emacs-lisp :tangle nicemacs-v2.el :comments link
  ;; Shell stuff
  ;; -----------
  ;;
  ;; TODO When running `git branch' in eshell there is a warning about
  ;; the terminal not being fully functional which requires the user to
  ;; type RET, it would be nice to disable the requirement to type RET,
  ;; or even ignore the warning altogether.
  ;;
  (setq eshell-cmpl-ignore-case t)
  (evil-leader/set-key
    "s e" 'eshell
    "s b" (lambda () (interactive) (ansi-term "/bin/bash"))
    "s i" 'ielm
    "s r" 'R)

  (defun cdf (filepath)
    "Change the current directory in Eshell to the directory of
   FILEPATH."
    (let ((dir (file-name-directory filepath)))
      (when (file-directory-p dir)
	(eshell/cd dir))))
#+end_src

** STUFF 2

#+begin_src emacs-lisp :tangle nicemacs-v2.el :comments link
  ;; Buffer stuff
  ;; ------------

  (evil-leader/set-key "b r" 'revert-buffer)

  ;; File stuff
  ;; ----------

  ;; TODO Configure functions to move/copy the most recent file in the
  ;; ~/Downloads directory to the current directory so that they can be
  ;; used from eshell.

  (require 'dired)
  (define-key dired-mode-map "-" 'dired-up-directory)
  (setq dired-listing-switches "-alh")

  (evil-leader/set-key-for-mode 'dired-mode
    "m s" 'dired-sort-toggle-or-edit)

  (evil-leader/set-key
    "f f" 'find-file
    "f l" 'find-file-literally
    "f t" 'nice-touch-file
    "f F" 'find-file-other-frame
    "f s" 'save-buffer
    "f d" 'nice-dired
    "b b" 'switch-to-buffer
    "d b" 'kill-buffer
    "d w" 'delete-window
    "d f" 'delete-frame)

  (defun nice-dired ()
    "Open dired for the current buffer's directory if it
   corresponds to a file, the working directory of the shell if
   the current buffer is a shell, or the home directory otherwise."
    (interactive)
    (let* ((buffer-mode (with-current-buffer (current-buffer) major-mode))
	   (dir (cond ((buffer-file-name)
		       (file-name-directory (buffer-file-name)))
		      ((or (eq buffer-mode 'term-mode)
			   (eq buffer-mode 'eshell-mode)
			   (eq buffer-mode 'inferior-ess-r-mode))
		       (with-current-buffer (if (eq buffer-mode 'inferior-ess-r-mode)
						(process-buffer (ess-get-process ess-current-process-name))
					      (current-buffer))
			 (file-name-directory default-directory)))
		      (t (expand-file-name "~/")))))
      (dired dir)))

  (defun nice-touch-file ()
    "In the current dired buffer touch a new file with a name
  retreived from the prompt."
    (interactive)
    (if (not (eq major-mode 'dired-mode))
	(error "Not in dired mode"))
    (let ((filename (read-string "Filename: ")))
      (shell-command (format "touch %s" filename))
      (revert-buffer)))

  (defmacro nice-scratch-buffer (mode key)
    "Create a nice-scratch-buffer function for MODE and bind it to KEY."
    (let ((func-name (intern (format "nice-scratch-buffer-%s" (symbol-name mode))))
	  (docstring (format "Open the scratch buffer and set the major mode to `%s'." mode)))
      `(progn
	 (defun ,func-name ()
	   ,docstring
	   (interactive)
	   (switch-to-buffer "*scratch*")
	   (,mode))
	 (evil-leader/set-key ,key ',func-name))))
  (nice-scratch-buffer text-mode "b s t")
  (nice-scratch-buffer org-mode "b s o")
  (nice-scratch-buffer emacs-lisp-mode "b s e")

  (evil-leader/set-key
    "w s" 'split-window-below
    "w v" 'split-window-right
    "TAB" 'next-window-and-pulse
    "<backtab>" 'previous-window-and-pulse
    "w L" 'evil-window-move-far-right
    "w H" 'evil-window-move-far-left
    "w J" 'evil-window-move-very-bottom
    "w K" 'evil-window-move-very-top)

  ;; Consult the oracle
  ;; ------------------

  (evil-leader/set-key
    "h s" 'apropos
    "h d b" 'message-buffer-file-name
    "h d f" 'describe-function
    "h d m" 'describe-mode
    "h d p" 'describe-package
    "h d k" 'describe-key
    "h d v" 'describe-variable)

  (defun message-buffer-file-name ()
    "Print the full path of the current buffer's file or directory to the
  minibuffer and store this on the kill ring."
    (interactive)
    (let ((path (or buffer-file-name
		    (and (eq major-mode 'dired-mode)
			 (dired-current-directory)))))
      (when path
	(kill-new path)
	(message path))))

  (defun message-link-at-point ()
    "Print the full path of a link at the point so we know where this
  will take us."
    (interactive)
    (let* ((link (org-element-context))
	   (link-file-name (org-element-property :path link)))
      (when (eq (org-element-type link) 'link)
	(kill-new link-file-name)
	(message "%s" link-file-name))))

  (evil-leader/set-key "h l m" 'message-link-at-point)

  ;; Learn from your past
  ;; --------------------

  (defmacro nice-rgrep-directory (dname path pattern key)
    "Create a function that calls `rgrep' on the specified DIRECTORY
  and binds it to a KEY.

  DNAME is the name of the directory used to generate the function
  name.
  PATH is the path to the directory to be searched.
  KEY is the keybinding (as a string) to trigger the rgrep function."
    `(progn
       (defun ,(intern (format "nice-rgrep-%s" dname)) ()
	 ,(format "Search for a string in %s using rgrep." dname)
	 (interactive)
	 (rgrep (read-string "Search terms: ") ,pattern ,path))
       (evil-leader/set-key ,(concat "s g " key) (intern ,(format "nice-rgrep-%s" dname)))))

  (nice-rgrep-directory "website" "~/public-site/org" "*" "w")
  (nice-rgrep-directory "notes" "~/public-site/org/notes" "*" "n")
  (nice-rgrep-directory "journal" "~/Documents/journal" "*.org" "j")
  (nice-rgrep-directory "reviews" "~/Documents/bibliography" "*" "r")

  (evil-leader/set-key "s g ." (lambda ()
				 (interactive)
				 (rgrep (read-string "Search terms: ")
					"*")))

  ;; Be virtuous and lead by example
  ;; ===============================

  (setq-default major-mode
		(lambda ()
		  (unless buffer-file-name
		    (let ((buffer-file-name (buffer-name)))
		      (set-auto-mode)))))
  (setq confirm-kill-emacs #'yes-or-no-p)
  (recentf-mode t)

  (setq read-buffer-completion-ignore-case t
	read-file-name-completion-ignore-case t
	completion-ignore-case t)

  ;; Write well
  ;; ----------

  ;; TODO Configure the =dictionary= command so that it works off of a
  ;; local copy of Webster's

  (setq sentence-end-double-space nil)

  (require 'flyspell)
  (require 'writegood-mode)
  (require 'lorem-ipsum)			; provide dummy text

  (setq ispell-program-name "aspell")
  (setq ispell-personal-dictionary "~/.aspell.en.pws")

  (defun nice-diff-dictionaries ()
    "Run ediff on the current ispell-personal-dictionary and the
  backup dictionary."
    (interactive)
    (let ((backup-dictionary
	   (concat nice-resources-dir "/aspell.en.pws")))
      (ediff-files ispell-personal-dictionary backup-dictionary)))

  (set-face-attribute 'flyspell-duplicate nil
		      :underline nil
		      :foreground "white"
		      :background "red")
  (set-face-attribute 'flyspell-incorrect nil
		      :underline nil
		      :foreground "white"
		      :background "red")

  (evil-leader/set-key
    "t S" 'flyspell-mode ; toggle flyspell on/off.
    "S b" 'flyspell-buffer
    "S r" 'flyspell-region
    "S c" 'flyspell-correct-word-before-point
    "S d" 'nice-diff-dictionaries)

  (setq words-to-add
	'("many" "various" "very" "quite" "somewhat" "several"
	  "extremely" "exceedingly" "fairly" "rather" "remarkably" "few"
	  "surprisingly" "mostly" "largely" "almost" "nearly" "in which"
	  "generally" "virtually" "essentially" "often" "substantially"
	  "significantly" "considerably" "typically" "widely" "really"
	  "actually" "basically" "certainly" "possibly" "probably"
	  "arguably" "likely" "apparently" "clearly" "naturally"
	  "obviously" "seemingly" "surely" "somewhat" "allegedly"
	  "supposedly" "purportedly" "perhaps" "maybe" "kind of"
	  "sort of" "potentially" "ultimately" "respectively"))
  (cl-loop for word in words-to-add
	   unless (member word writegood-weasel-words)
	   do (add-to-list 'writegood-weasel-words word))

  (evil-leader/set-key "t w" 'writegood-mode)

  ;; Be powerful with packages
  ;; =========================

  ;; NXML
  ;; ----

  ;; u - up to parent.
  ;; p - previous tag.
  ;; n - next tag.
  (evil-leader/set-key-for-mode 'nxml-mode
    "m u" 'nxml-backward-up-element
    "m p" 'nxml-backward-element
    "m n" 'forward-sexp)
#+end_src

** Yasnippet

I have a collection of yasnippets [[https://github.com/aezarebski/whipper-snipper][here]].

#+begin_src emacs-lisp :tangle nicemacs-v2.el :comments link
  ;; Yasnippet
  ;; ---------
  ;;
  ;; See https://github.com/aezarebski/whipper-snipper

  (require 'yasnippet)
  (yas-global-mode 1)

  (defun nice-load-snippets ()
    "Load the snippets in ~/.emacs.d/snippets."
    (interactive)
    (let ((snippets-dir "~/.emacs.d/snippets"))
      (unless (file-exists-p snippets-dir)
	(make-directory snippets-dir))
      (yas-load-directory snippets-dir)))

  (nice-load-snippets)

  (evil-leader/set-key
    "y i" 'yas-insert-snippet     ; Insert a snippet
    "y n" 'yas-new-snippet        ; Create a new snippet
    "y v" 'yas-visit-snippet-file ; Visit the snippet file for the current mode
    "y r" 'yas-reload-all         ; Reload all snippets
    "y c" 'yas-compile-directory  ; Compile all snippets
    "y l" 'nice-load-snippets     ; Load your custom snippets
    "y g" 'nice-go-to-snippets-dir)

  (defun nice-go-to-snippets-dir ()
    "Open the snippets directory in dired."
    (interactive)
    (dired "~/.emacs.d/snippets"))
#+end_src

** STUFF 3

#+begin_src emacs-lisp :tangle nicemacs-v2.el :comments link
  ;; Multiple cursors
  ;; ----------------
  ;;
  ;; Using mutiple cursors is a little bit tricky but here are some
  ;; simple steps you can try on the following example text.
  ;;
  ;; ```
  ;; the cat sat on the mat
  ;; catch this ball said pat
  ;; the food was eaten by the cat
  ;; ```
  ;;
  ;; 1. Select the an instance of "cat" with the cursor at the start
  ;; 2. Use the keys below, e.g. `SPC c n` to select occurrences
  ;; 3. Use `evil-insert' (`SPC c i`) to start editing.
  ;; 4. Exit using `mc/keyboard-quit' (`SPC c q`)

  (use-package multiple-cursors
    :ensure t)

  (use-package evil-mc
    :ensure t
    :config (global-evil-mc-mode 1))

  (evil-leader/set-key
    "c n" 'mc/mark-next-like-this        ; Mark next occurrence
    "c p" 'mc/mark-previous-like-this    ; Mark previous occurrence
    "c N" 'mc/skip-to-next-like-this     ; Skip and mark next occurrence
    "c P" 'mc/skip-to-previous-like-this ; Skip and mark previous occurrence
    "c u" 'mc/unmark-next-like-this      ; Unmark next cursor
    "c U" 'mc/unmark-previous-like-this  ; Unmark previous cursor
    "c i" 'evil-insert                   ; Drop into using the cursors
    "c q" 'mc/keyboard-quit              ; Quit multiple-cursors mode
    )
#+end_src

** Magit

*** Staging and unstaging multiple files

You can select multiple files to unstage in one go using the region.
To do this, follow these steps:

1. Navigate to the "Staged changes" section in the Magit status
   buffer.
2. Move the cursor to the first file you want to unstage.
3. Set the mark by pressing =C-SPC= (Control + Space).
4. Move the cursor to the last file you want to unstage. This will
   create a region that includes all the files you want to unstage.
5. Press =u= to unstage all the files in the region.

You can also use the same method to stage multiple files in the
"Unstaged changes" section. Just follow the same steps, but press =s=
instead of =u= in step 5 to stage the files in the region.

*** Configuration

#+begin_src emacs-lisp :tangle nicemacs-v2.el :comments link
  ;; Magit
  ;; -----

  (require 'magit)

  (evil-leader/set-key "g s" 'magit-status)

  (defmacro nice-canned-commit-message (fname cmessage key)
    "Define a canned commit message function with an Evil key binding.

    This macro takes in three arguments:
    - FNAME: A string that will be used to construct the function name.
    - CMESSAGE: A string that represents the canned commit message.
    - KEY: A string that represents the keybinding for the function using the Evil leader.

    The function created by this macro generates a commit message with a timestamp by
    concatenating the specified CMESSAGE string with the current day and time. The commit
    is created using `magit-commit-create', which is invoked with the `--edit` option to
    open the commit message in an editor. The function is bound to the Evil leader key
    sequence `g c KEY`, where `KEY` is the specified key string.

    Example usage:
    (nice-canned-commit-message \"my-canned-commit\" \"Fix some bugs\" \"c\")"
    `(progn
       (defun ,(intern (format "nccm-%s" fname)) ()
	 "Generate a canned commit message with a timestamp."
	 (interactive)
	 (let ((commit-message (format "%s %s"
				       ,cmessage
				       (downcase (format-time-string "%A %l:%M %p")))))
	   (magit-commit-create (list "--edit" (concat "-m \"" commit-message "\"")))))
       (evil-leader/set-key ,(concat "g c " key) (intern ,(format "nccm-%s" fname)))))

  (nice-canned-commit-message emacs "update emacs config" "e")
  (nice-canned-commit-message notes "update notes" "n")
  (nice-canned-commit-message review "update reading list" "r")
  (nice-canned-commit-message website "update website" "w")
  (nice-canned-commit-message journal "update journal" "j")
  (nice-canned-commit-message yasnippet "yasnippet" "y")

  (setq magit-display-buffer-function
	#'magit-display-buffer-fullframe-status-v1)

  (evil-leader/set-key "g q" 'with-editor-cancel)
#+end_src

** Emacs lisp

- [[https://github.com/p3r7/awesome-elisp][Awesome Elisp]] sounds like it would be a good place to go to learn a bit more
  elisp.

The =pp-sexp-to-kill-ring= function is there to help pretty print code. It uses
a new pretty printer function included in 29.1 and puts the pretty-printed
version of an S-expression on the kill ring.

#+begin_src emacs-lisp :tangle nicemacs-v2.el :comments link
  ;; Emacs Lisp
  ;; ----------

  (setq pp-max-width 70)
  (setq pp-use-max-width t)

  (defun pp-sexp-to-kill-ring ()
    "Pretty-print the S-expression under the cursor and add it to the
  kill ring."
    (interactive)
    (let ((sexp (read (thing-at-point 'sexp)))
	  (temp-buffer (generate-new-buffer "*temp*")))
      (with-current-buffer temp-buffer
	(pp-emacs-lisp-code sexp)
	(kill-new (buffer-string)))
      (kill-buffer temp-buffer)))

  (evil-leader/set-key-for-mode 'emacs-lisp-mode
    "m s c" 'eval-last-sexp
    "m s b" 'eval-buffer
    "m s r" 'eval-region
    "m c l" 'pp-sexp-to-kill-ring)
#+end_src

** Emacs Speaks Statistics (ESS)

#+begin_src emacs-lisp :tangle nicemacs-v2.el :comments link
  ;; Emacs Speaks Statistics (ESS)
  ;; -----------------------------

  (use-package ess
    :ensure t
    :mode ("\\.Rmd" . Rmd-mode)
    :config
    (setq ess-default-style 'DEFAULT)
    (evil-leader/set-key-for-mode 'ess-r-mode
      "m d t" 'ess-r-devtools-test-package
      "m d l" 'ess-r-devtools-load-package
      "m d b" 'ess-r-devtools-build-package
      "m d i" 'ess-r-devtools-install-package
      "m d c" 'ess-r-devtools-check-package
      "m d d" 'ess-r-devtools-document-package
      "m s b" 'ess-eval-buffer
      "m s r" 'ess-eval-region
      "m s c" 'ess-eval-region-or-line-visibly-and-step
      "m c l" 'nice-code-lint-buffer-r
      "m c i" 'indent-region
      "m '" 'ess-switch-to-inferior-or-script-buffer))

  (require 'ess-site)
  (require 'quarto-mode)

  (defun nice-code-lint-buffer-r ()
    "Lint the current R buffer using lintr."
    (interactive)
    (ess-eval-linewise "library(lintr)\n")
    (ess-eval-linewise (format "print(lint(\"%s\"))\n" buffer-file-name)))
#+end_src

** STUFF 4

#+begin_src emacs-lisp :tangle nicemacs-v2.el :comments link
  ;; Python
  ;; ------
  ;;
  ;; Use `pyvenv-activate' to activate a virtual environment.

  (use-package pyvenv
    :ensure t)

  (use-package python
    :ensure t
    :config
    (setq python-shell-interpreter "python3")
    (setq python-indent-offset 4))

  (evil-leader/set-key-for-mode 'python-mode
    "m s b" 'python-shell-send-buffer
    "m s r" 'python-shell-send-region
    "m '" 'python-shell-switch-to-shell)
#+end_src

** Scheme/Racket *NO LONGER USED*

#+begin_src emacs-lisp
  ;; Scheme/Racket
  ;; -------------

  ;; TODO Work out how to start a repl properly, running the key does
  ;; not seem to work, I need to run the command via M-x directly.

  (require 'racket-mode)
  (add-to-list 'auto-mode-alist '("\\.rkt\\'" . racket-mode))
  (setq racket-program "/usr/bin/racket")

  (evil-leader/set-key-for-mode 'racket-mode
    "m h d" 'racket-describe-search
    "m s b" 'racket-run
    "m s r" 'racket-send-region
    "m s c" 'racket-send-last-sexp)
#+end_src

** LaTeX/BibTeX

#+begin_src emacs-lisp :tangle nicemacs-v2.el :comments link
  ;; LaTeX/BibTeX
  ;; ------------

  ;; TODO Configure this so that there is a good way to search the key
  ;; bibtex files, perhaps with a SQL type search

  ;; TODO Configure this so there is the command to convert ris to bib.

  ;; TODO Find a better way to search BIB files.

  (defun most-recent-file (files)
    "Return the most recent file from a list of FILES.
  FILES should be a list of file paths as strings."
    (when (and files (seq-every-p #'stringp files))
      (cl-flet* ((file-mod-time (file)
		   (nth 5 (file-attributes file)))
		 (mod-time-less-p (a b)
		   (time-less-p (file-mod-time b)
				(file-mod-time a))))
	(car (sort files #'mod-time-less-p)))))

  (defun copy-file-with-bib-extension (file-path)
    "Create a copy of the file at FILE-PATH with a .bib extension."
    (let* ((file-name (file-name-nondirectory file-path))
	   (file-base-name (file-name-sans-extension file-name))
	   (new-file-name (concat file-base-name ".bib"))
	   (new-file-path (concat (file-name-directory file-path) new-file-name)))
      (copy-file file-path new-file-path t)
      new-file-path))

  (defun nice-visit-last-bib ()
    "Visit the most recent BIB file in Downloads. If there is a TXT
  file that is younger than the last BIB file, send a message to
  indicate this."
    (interactive)
    (let* ((bib-files (directory-files "~/Downloads" t ".*bib" "ctime"))
	   (most-recent-bib (most-recent-file bib-files))
	   (txt-files (directory-files "~/Downloads" t ".*txt" "ctime"))
	   (most-recent-txt (most-recent-file txt-files)))
      (if most-recent-bib
	  (if (and most-recent-txt
		   (time-less-p (nth 5 (file-attributes most-recent-bib))
				(nth 5 (file-attributes most-recent-txt))))
	      (progn (message (concat "A more recent .txt file exists: " most-recent-txt))
		     (find-file (copy-file-with-bib-extension most-recent-txt)))
	    (find-file most-recent-bib))
	(message "No bib files found in ~/Downloads/"))))

  (defun nice-ris2bib ()
    "Convert the most recent RIS file in my downloads to a BIB
  file. Signal an error if there are no RIS files or if the
  conversion fails."
    (interactive "*")

    (let* ((all-ris-files (directory-files "~/Downloads" t ".*ris"))
	   (ris-filepath (most-recent-file all-ris-files))
	   (target-bib "~/Downloads/new.bib")
	   (ris2xml-command (format "ris2xml \"%s\" | xml2bib > %s" ris-filepath
				    target-bib))
	   (command-result (shell-command ris2xml-command)))
      (unless ris-filepath
	(error "No RIS files found in the directory"))
      (unless (zerop command-result)
	(error "Conversion from RIS to BIB failed with error code: %s" command-result))))

  (defun nice-bibtex-braces ()
    "Wrap upper case letters with brackets for bibtex titles within
  the selected region."
    (interactive)
    (if (use-region-p)
	(let ((start (region-beginning))
	      (end (region-end))
	      (case-fold-search nil))
	  (save-excursion
	    (goto-char start)
	    (while (re-search-forward "\\([A-Z]+\\)" end t)
	      (replace-match (format "{%s}" (match-string 0)) t))))
      (message "No region selected.")))

  (defun nice-bibtex-guess-key ()
    "Generate a new key for the current BibTeX entry based on author,
  year, and the first two words of the title."
    (interactive)
    (bibtex-beginning-of-entry)
    (let* ((entry (bibtex-parse-entry))
	   (author (downcase (replace-regexp-in-string "," "" (car (split-string (bibtex-text-in-field "author"))))))
	   (year (bibtex-text-in-field "year"))
	   (title (bibtex-text-in-field "title"))
	       (first-two-words (when title
			  (let ((split-title (split-string title)))
			    (if (>= (length split-title) 2)
				(format "%s%s" (nth 0 split-title) (nth 1 split-title))
			      (car split-title))))))
      (if (and author year first-two-words)
	  (let ((newkey (format "%s%s%s" author year first-two-words)))
	    (kill-new newkey)
	    (message "New key generated and copied to clipboard: %s" newkey))
	(error "Author, Year or Title is missing in the current BibTeX entry."))))

  (defun nice-browse-url-of-doi ()
    "Open the DOI of the current bibtex entry in the web browser."
    (interactive)
    (save-excursion
      (bibtex-beginning-of-entry)
      (let ((doi (bibtex-autokey-get-field "doi")))
	(if doi
	    (browse-url (concat "https://doi.org/" doi))
	  (message "No DOI found for this entry")))))

  (evil-leader/set-key
    "v b l" 'nice-visit-last-bib
    "v b d" 'nice-browse-url-of-doi
    "v b r" 'nice-ris2bib)

  (evil-leader/set-key-for-mode 'bibtex-mode
    "m b b" 'nice-bibtex-braces
    "m b f" 'bibtex-reformat
    "m b k" 'nice-bibtex-guess-key)
#+end_src

** Markdown

#+begin_src emacs-lisp :tangle nicemacs-v2.el :comments link
  ;; Markdown-mode
  ;; -------------

  (use-package markdown-mode
    :mode (("\\.md\\'" . markdown-mode)))
#+end_src

** Org-mode

- There is a function =org-table-sort-lines= which sorts the rows of a table
  based on a column (1-indexed) with a variety of datatypes acceptable.

#+begin_src emacs-lisp :tangle nicemacs-v2.el :comments link
  ;; Org-Mode
  ;; --------

  ;; NOTE It would be nice to have an additional command and key for
  ;; moving from level n+1 headers their parent level n header.

  ;; FIXME Work out why the configuration based approach does not work!
  (setq org-return-follows-link t)
  (evil-leader/set-key-for-mode 'org-mode "RET" 'org-open-at-point)

  (defun nice-org-mode-hook ()
    "Set up org-mode specific keybindings."
    (local-set-key (kbd "<tab>") #'org-cycle))

  (add-hook 'org-mode-hook #'nice-org-mode-hook)
#+end_src

*** Agenda and calendar

#+begin_src emacs-lisp :tangle nicemacs-v2.el :comments link
  ;; Org-agenda
  ;; ----------
  ;;
  ;; - `n/p' to move up and down lines.
  ;; - `v-d' will show the day view.
  ;; - `v-w' the week view.
  ;; - `v-m' the month view.
  ;; - `v-SPC' resets the view.
  ;; - `.' goes to today.
  ;; - `j' will /jump/ to a date (selected via calendar).
  ;; - `t' will cycle through TODO/DONE
  ;; - `S-<left/right>' moves the scheduled date backwards/forwards
  ;; - `r' rebuilds the agenda view
  ;;
  (setq org-agenda-start-day "-14d")
  (setq org-agenda-span 30)
  (setq org-agenda-start-on-weekday nil)

  (defun nice-org-agenda-goto-today-advice-after (&rest _args)
    "Adjust the window after calling `org-agenda-goto-today'."
    (recenter-top-bottom 4))

  (advice-add 'org-agenda-goto-today
	      :after #'nice-org-agenda-goto-today-advice-after)
  (evil-leader/set-key-for-mode 'org-mode "a s" 'org-schedule)

  ;; Calendar view
  ;;
  ;; This provides a more classical view of the agenda as a calendar.
  ;;
  (use-package calfw
    :ensure t
    :config
    (use-package calfw-org))

  (evil-leader/set-key
    "a a" 'org-agenda
    "a c" 'cfw:open-org-calendar)
#+end_src

*** Literate programming

#+begin_src emacs-lisp :tangle nicemacs-v2.el :comments link
  ;; Literate programming

  (use-package polymode
    :ensure t
    :mode ("\\.org$" . poly-org-mode)
    :config
    (add-to-list 'auto-mode-alist '("\\.org$" . poly-org-mode)))

  (use-package poly-R
    :ensure t
    :after polymode)

  (use-package poly-org
    :ensure t
    :after polymode)

  (org-babel-do-load-languages
   'org-babel-load-languages
   '((R . t)))

  (evil-leader/set-key-for-mode 'org-mode "b t" 'org-babel-tangle)

  (defun nice-detangle-nicemacs-v2 ()
    "Detangle the nicemacs-v2.el file."
    (interactive)
    (let ((nicemacs-v2-source (concat nice-nicemacs-directory
				      "/nicemacs-v2.el")))
      (org-babel-detangle nicemacs-v2-source)))

  (evil-leader/set-key-for-mode 'emacs-lisp-mode "b d"
    'nice-detangle-nicemacs-v2)

  (setq org-image-actual-width 300)
  (evil-leader/set-key-for-mode 'org-mode
    "o t l" 'org-latex-preview
    "o t i" 'org-toggle-inline-images)
#+end_src

*** Website/Publishing

#+begin_src emacs-lisp :tangle nicemacs-v2.el :comments link
  (defun nice-publish-homepage ()
    "Copy my website homepage if it exists."
    (interactive)
    (let ((local "~/public-site/org/scratch.html")
	  (remote "~/aezarebski.github.io/index.html"))
      (when (file-exists-p local)
	(copy-file local remote t)
	(message "Copied %s to %s" local remote))))

  ;; The following projects are available for publishing when the
  ;; `org-publish' command is given.
  (setq org-publish-project-alist
	`(("website-notes-org-files"
	   :base-directory "~/public-site/org/notes/"
	   :base-extension "org"
	   :publishing-directory "~/aezarebski.github.io/notes/"
	   :publishing-function org-html-publish-to-html)
	  ("website-lists-org-files"
	   :base-directory "~/public-site/org/lists/"
	   :base-extension "org"
	   :publishing-directory "~/aezarebski.github.io/lists/"
	   :publishing-function org-html-publish-to-html)
	  ("website-images-static"
	   :base-directory "~/public-site/org/images/"
	   :base-extension "png"
	   :publishing-directory "~/aezarebski.github.io/images/"
	   :publishing-function org-publish-attachment)
	  ("website-misc-ggplot2-org-files"
	   :base-directory "~/public-site/org/misc/ggplot2/"
	   :base-extension "org"
	   :publishing-directory "~/aezarebski.github.io/misc/ggplot2/"
	   :publishing-function org-html-publish-to-html)
	  ("website-misc-ggplot2-static"
	   :base-directory "~/public-site/org/misc/ggplot2/"
	   :base-extension "png\\|jpg\\|pdf"
	   :publishing-directory "~/aezarebski.github.io/misc/ggplot2/"
	   :publishing-function org-publish-attachment)
	  ("website-misc-basegraphicsR-org-files"
	   :base-directory "~/public-site/org/misc/basegraphicsR/"
	   :base-extension "org"
	   :publishing-directory "~/aezarebski.github.io/misc/basegraphicsR/"
	   :publishing-function org-html-publish-to-html)
	  ("website-misc-basegraphicsR-static"
	   :base-directory "~/public-site/org/misc/basegraphicsR/"
	   :base-extension "png\\|jpg\\|pdf"
	   :publishing-directory "~/aezarebski.github.io/misc/basegraphicsR/"
	   :publishing-function org-publish-attachment)
	  ("website-misc-latex-org-files"
	   :base-directory "~/public-site/org/misc/latex/"
	   :base-extension "org"
	   :publishing-directory "~/aezarebski.github.io/misc/latex/"
	   :publishing-function org-html-publish-to-html)
	  ("website-misc-latex-static"
	   :base-directory "~/public-site/org/misc/latex/"
	   :base-extension "png\\|jpg\\|pdf"
	   :publishing-directory "~/aezarebski.github.io/misc/latex/"
	   :publishing-function org-publish-attachment)
	  ("website-misc-tikz-org-files"
	   :base-directory "~/public-site/org/misc/tikz/"
	   :base-extension "org"
	   :publishing-directory "~/aezarebski.github.io/misc/tikz/"
	   :publishing-function org-html-publish-to-html)
	  ("website-misc-tikz-static"
	   :base-directory "~/public-site/org/misc/tikz/"
	   :base-extension "png\\|jpg\\|pdf"
	   :publishing-directory "~/aezarebski.github.io/misc/tikz/"
	   :publishing-function org-publish-attachment)
	  ("review2-org"
	   :base-directory "~/Documents/bibliography/review2"
	   :base-extension "org"
	   :publishing-directory "~/aezarebski.github.io/notes/review2"
	   :recursive ()
	   :publishing-function org-html-publish-to-html
	   )
	  ("review2-static"
	   :base-directory "~/Documents/bibliography/review2"
	   :base-extension "css\\|png"
	   :publishing-directory "~/aezarebski.github.io/notes/review2"
	   :recursive t
	   :publishing-function org-publish-attachment
	   )
	  ("nicemacs-org-files"
	   :base-directory "~/Documents/nicemacs/"
	   :base-extension "org"
	   :publishing-directory "~/aezarebski.github.io/misc/nicemacs/"
	   :publishing-function org-html-publish-to-html)
	  ("R"
	   :components ("website-misc-basegraphicsR-org-files"
			"website-misc-basegraphicsR-static"
			"website-misc-ggplot2-org-files"
			"website-misc-ggplot2-static"))
	  ("review"
	   :components ("review2-org"
			"review2-static"))
	  ("latex"
	   :components ("website-misc-latex-org-files"
			"website-misc-latex-static"
			"website-misc-tikz-org-files"
			"website-misc-tikz-static"))
	  ("website"
	   :components ("website-notes-org-files"
			"website-images-static"
			"website-lists-org-files"
			"nicemacs-org-files"
			"review"
			"latex"
			"R"))))
#+end_src

** STUFF 8

#+begin_src emacs-lisp :tangle nicemacs-v2.el :comments link
  ;; Visitors
  ;; ========

  (defmacro NVNF (fname pname file key)
    "Macro to define a function for visiting a notes file and set an Evil leader key binding.

    This macro takes in four arguments:
    - FNAME: A string that will be used to construct the function name.
    - PNAME: A string that will be used in the message displayed to the user.
    - FILE: A string that represents the name of the notes file.
    - KEY: A string that represents the keybinding for the function using the Evil leader.

    The function created by this macro opens the notes file specified by FILE in
    the directory specified by `nice-notes-directory'. The keybinding is set using
    the Evil leader, and is constructed using the specified KEY string.

    Example usage:
    (NVNF \"my-notes\" \"My Notes\" \"my-notes.org\" \"n\")"

    `(progn
       (defun ,(intern (format "nice-visit-%s" fname)) ()
	 "Visit a notes file."
	 (interactive)
	 (progn
	   (message ,(format "Visiting %s" pname))
	   (find-file ,(concat nice-notes-directory "/" file))))
       (evil-leader/set-key ,(concat "v n " key) (intern ,(format "nice-visit-%s" fname)))))

  (defmacro NVF (fname pname file key)
    `(progn
       (defun ,(intern (format "nice-visit-%s" fname)) ()
	 "Visit a file."
	 (interactive)
	 (progn
	   (message ,(format "Visiting %s" pname))
	   (find-file ,file)))
       (evil-leader/set-key ,(concat "v f" key) (intern ,(format "nice-visit-%s" fname)))))

  (defmacro NVD (dname pname path key)
    "Macro to define a function for visiting a directory and set an Evil leader key binding.

    This macro takes in four arguments:
    - DNAME: A string that will be used to construct the function name.
    - PNAME: A string that will be used in the message displayed to the user.
    - PATH: A string that represents the path of the directory.
    - KEY: A string that represents the keybinding for the function using the Evil leader.

    The function created by this macro jumps to the directory specified by PATH using `dired-jump'.
    The keybinding is set using the Evil leader, and is constructed using the specified KEY string.

    Example usage:
    (NVD \"my-dir\" \"My Directory\" \"/path/to/directory\" \"d\")"

    `(progn
       (defun ,(intern (format "nice-visit-%s" dname)) ()
	 "Visit a directory."
	 (interactive)
	 (progn
	   (message ,(format "Visiting %s" pname))
	   (dired-jump nil ,path)
	   (revert-buffer)))
       (evil-leader/set-key ,(concat "v d " key) (intern ,(format "nice-visit-%s" dname)))))

  (NVF nicemacs2-init "Nicemacs v2 init.el" "~/.emacs.d/init.el" "e 2")
  (NVF nicemacs-init "Nicemacs v1 nicemacs.el" "~/Documents/nicemacs/nicemacs.el" "e 1")
  (NVF nicemacs-org "Nicemacs v1 nicemacs.org" "~/Documents/nicemacs/nicemacs.org" "e 1")
  (NVF review-2 "Review 2" "~/Documents/bibliography/review2/review.org" "r 2")
  (NVF review-references "Bibtex references" "~/Documents/bibliography/references.bib" "r r")

  (NVNF academia-notes "Academia notes" "academic-journal-notes.org" "a")
  (NVNF beast-notes "BEAST2 notes" "beast2-notes.org" "b")
  (NVNF git-notes "Git notes" "git-notes.org" "g")
  (NVNF haskell-notes "Haskell notes" "haskell-notes.org" "h")
  (NVNF java-notes "Java notes" "java-notes.org" "j")
  (NVNF latex-notes "LaTeX notes" "latex-notes.org" "l")
  (NVNF maxima-notes "Maxima notes" "maxima-notes.org" "m")
  (NVNF org-mode-notes "org-mode notes" "org-mode-notes.org" "o")
  (NVNF python-notes "Python notes" "python-notes.org" "p")
  (NVNF r-notes "R notes" "r-notes.org" "r")
  (NVNF ubuntu-notes "Ubuntu/Linux notes" "linux-notes.org" "u")

  (NVD library "Library" "~/Documents/library/fake.org" "l")
  (NVD manuscripts "Manuscripts" "~/Documents/manuscripts/fake.org" "m")
  (NVD music "Music" "~/Music/fake.org" "M")
  (NVD documents "Documents" "~/Documents/fake.org" "d")
  (NVD downloads "Downloads" "~/Downloads/fake.org" "D")
  (NVD professional "Professional" "~/Documents/professional/README.org" "p")
  (NVD projects "Projects" "~/projects/fake.org" "P")
  (NVD teaching "Teaching" "~/Documents/teaching/fake.org" "t")
  (NVD website-org "Website (org files)" "~/public-site/org/fake.org" "w")
  (NVD website-html "Website (HTML files)" "~/aezarebski.github.io/fake.org" "W")
  (NVD notes "My notes" "~/public-site/org/notes/fake.org" "n")
  (NVD yasnippet "Yasnippet" "~/.emacs.d/snippets/fake.org" "y")

  (setq org-agenda-files
	(list (concat nice-journal-directory "bike.org")))

  (defun nice-visit-journal ()
    "Opens the current journal file. If it does not yet exist, it
    makes a copy of the one from one week ago. This will also
    ensure that the current journal file is among the org agenda
    files and that a previous one is not."
    (interactive)
    (let* ((filepath-template (concat nice-journal-directory "journal-%s.org"))
	   (curr-file (format filepath-template (format-time-string "%Y-%m")))
	   (prev-file (format filepath-template (format-time-string "%Y-%m" (time-subtract (current-time) (* 7 24 60 60))))))
      (unless (file-exists-p curr-file)
	(message "Creating new journal file")
	(copy-file prev-file curr-file))
      (message "Opening journal file")
      (when (member prev-file org-agenda-files)
	(setq org-agenda-files (remove prev-file org-agenda-files)))
      (unless (member curr-file org-agenda-files)
	(add-to-list 'org-agenda-files curr-file))
      (find-file curr-file)
      (goto-char (point-min))
      (recenter-top-bottom)))

  (evil-leader/set-key "v f j" 'nice-visit-journal)
#+end_src

** STUFF 9

#+begin_src emacs-lisp :tangle nicemacs-v2.el :comments link
  ;; Copilot
  ;; =======
  ;;
  ;; To install this you need to clone the repository and a couple of
  ;; dependencies yourself: s, editorconfig which are emacs packages and
  ;; node.js.
  ;;

  (use-package copilot
    :defer 1
    :config
    (evil-leader/set-key "t c" 'copilot-mode)
    (setq copilot-node-executable "~/.nvm/versions/node/v17.3.1/bin/node")
    ;; (setq copilot-node-executable "/usr/bin/node")
    :load-path "~/.emacs.d/copilot.el/"
    :hook ((python-mode . copilot-mode)
	   (ess-r-mode . copilot-mode)))

  (defun nice-copilot-tab ()
    "Accept the current suggestion provided by copilot."
    (interactive)
    (or (copilot-accept-completion)
	(indent-for-tab-command)))

  (with-eval-after-load 'copilot
    (evil-define-key 'insert copilot-mode-map
      (kbd "<tab>") #'nice-copilot-tab))

  (defun nice-copilot-by-line ()
    "Accept the current suggestion by line."
    (interactive)
    (or (copilot-accept-completion-by-line)
	(indent-for-tab-command)))

  (with-eval-after-load 'copilot
    (evil-define-key 'insert copilot-mode-map
      (kbd "C-<tab>") #'nice-copilot-by-line))


  ;; Explore new worlds
  ;; ==================

  ;; TODO Work out how to browse gopher with =gopher.el=.

  ;; TODO Work out how to configure auth-source.

  ;; TODO Work out how to use mediawiki-mode to read and edit wikipedia.

  ;; TODO Explore running spotify through emacs

  ;; Customization
  ;; =============

  ;; There be dragons here
  ;; ---------------------
#+end_src

* GNU Emacs

The notes here are intended to deal exclusively with GNU emacs without
the use of packages other than those that are provided with emacs.

** Build you an Emacs

Get the source code from [[http://git.savannah.gnu.org/cgit/emacs.git/][here]] with

#+begin_src sh
  wget http://git.savannah.gnu.org/cgit/emacs.git/snapshot/emacs-VERSION.tar.gz
  tar -xf emacs-VERSION.tar.xz
#+end_src

Alternatively, you can get clone the [[https://github.com/emacs-mirror/emacs][emacs mirror]] from GitHub and check out the
=emacs-28= branch (or whatever version you want).

Follow the instructions in the =INSTALL= file to build emacs.
- This seems to just be =./configure= then =make= then =sudo make install=.
  + =./configure --with-native-compilation --with-rsvg=.
- If you cannot find the =configure= script, you may need to run =autogen.sh= first.
- If you have spare compute you can use multiple jobs to speed up the
  compilation with =make -j [N]= to use =N= jobs during compilation

*** Notes

- =emacs-29.0.60= on a new laptop:
  =./configure --with-native-compilation --with-tree-sitter --without-x --with-pgtk=
  because it uses Wayland.
- =emacs-29.0.60= configured with =--with-native-compilation=, and
  =--with-tree-sitter= . This took a bit of fiddling because it couldn't find
  the correct version of the JIT library which turned out to be
  =libgccjit-11-dev= and I couldn't work out how to compile tree-sitter from
  source.
- =emacs-28.2=
- =emacs-28.1.90= configured with =--with-native-compilation= and =--with-rsvg=.
  Building this one seemed to take longer than normal.
- =emacs-28.1=. I also installed =libgccjit= and used =./configure
  --with-native-compilation= during the compilation, it does feel snappier.
- =emacs-28.0.91= requested =mailutils= to be installed during configuration.
- =emacs-28.0.60= requested =libacl1-dev= and =libharfbuzz-dev= be installed during
  configuration. It does feel snappier. It told me that my current version of
  GTK+ leads to a bug but I couldn't figure out how to update GTK+ and it seemed
  to be an up to date version anyway.
- =emacs-27.2= build and installs without issue.

** Recording keyboard macros

1. Start recording with =C-x (= (which calls =kmacro-start-macro=).
2. Stop recording with =C-x )= (which calls =kmacro-end-macro=).
3. Execute the recording with =C-x e= (which calls =kmacro-end-and-call-macro=).

If you want to save a macro for later use, you can get a emacs-lisp definition
of it with =insert-kbd-macro=.

** Buffer specific variables

Suppose you wanted to set the =fill-column= for a specific file, add
the following to the end of the file to set it to 80 for this file.

#+begin_src latex
% Local Variables:
% fill-column: 80
% End:
#+end_src

** Jargon

There is a [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Glossary.html][glossary]] in the manuals, the nodes are =Emacs > Glossary=. The regex
search entered with =s= is very useful here.

** Mastering Emacs

Here are some notes from reading /Mastering Emacs/.

*** Chapter 2

- "In Emacs, /the buffer is the data structure/."
- A /window/ is a tiled portion of a /frame/.
- The /modeline/ is the portion at the bottom of a window that displays
  information such as the name of the buffer displayed and the major mode.
- The /minibuffer/ is the below the modeline and displays messages.
- The /point/ is the current position of the cursor.
- The /region/ is a selection of text which has the point at one end and the
  /mark/ at the other. The region is visually displayed with the /transient mark
  mode/ (TMM).
- /killing/ is cutting text, /yanking/ is pasting it, and /saving to the kill
  ring/ is copying.
- /font locking/ is syntax highlighting.

*** Chapter 3

- In order for a function to be executed by =M-x=, it needs to be made
  /interactive/.
- /apropos/ is a system to for discovery:
  + =apropos= searches everything,
  + =apropos-command= searches commands,
  + and =apropos-documentation= searches documentation.
- The /describe/ system is a collection of functions that allow you to obtain
  information about known items:
  + =describe-mode=,
  + =describe-function=,
  + =describe-variable=,
  + and =describe-key=.

*** Chapter 4

*** Chapter 5

*** Chapter 6

- There is the function =read-only-mode= which toggles read only mode, which
  replaces the obsolete =toggle-read-only= function.
  + In Spacemacs this is bound to =SPC b w= which seems strange.

*** Chapter 7

** Getting HELP

There are a couple of help menus that are useful to be able to access easily:

- /GNU Emacs NEWS/ can be summoned with =view-emacs-news=.
- /Spacemacs documentation/ can be summoned with =helm-spacemacs-help-docs=.
- /GNU Emacs Manual/ can be summoned with =info-display-manual=.
- /Emacs Lisp Intro/ has a section on debugging.

*** Info navigation

The following are key-bindings for emacs mode (use =\= to call
=evil-execute-in-emacs-state=):

- =n= next node
- =p= previous node
- =^= will move up
- =RET= will follow a link
- =l= return to the last node visited
- =s= search with a regex
- =f= find a node linked from here
- =d= go to the root node

* Footnotes

#  LocalWords:  nicemacs Spacemacs spacemacs SPC REPL Eshell npm magit dired
#  LocalWords:  defmacro backend LSP Bibtex NodeJS Edebug edebug defun ielm ESS
#  LocalWords:  REPLs modeline minibuffer sexp eval src
